diff --git a/packages/compiler-cli/src/compiler_host.ts b/packages/compiler-cli/src/compiler_host.ts
index 41d781a..19c3598 100644
--- a/packages/compiler-cli/src/compiler_host.ts
+++ b/packages/compiler-cli/src/compiler_host.ts
@@ -232,7 +232,7 @@ export class CompilerHost implements AotCompilerHost {
     }
   }
 
-  private upgradeVersion1Metadata(v1Metadata: ModuleMetadata, dtsFilePath: string): ModuleMetadata {
+  protected upgradeVersion1Metadata(v1Metadata: ModuleMetadata, dtsFilePath: string): ModuleMetadata {
     // patch up v1 to v3 by merging the metadata with metadata collected from the d.ts file
     // as the only difference between the versions is whether all exports are contained in
     // the metadata and the `extends` clause.
diff --git a/packages/compiler-cli/src/path_mapped_compiler_host.ts b/packages/compiler-cli/src/path_mapped_compiler_host.ts
index 2463b5b..5fc2d2a 100644
--- a/packages/compiler-cli/src/path_mapped_compiler_host.ts
+++ b/packages/compiler-cli/src/path_mapped_compiler_host.ts
@@ -16,6 +16,7 @@ import {CompilerHost, CompilerHostContext} from './compiler_host';
 
 const EXT = /(\.ts|\.d\.ts|\.js|\.jsx|\.tsx)$/;
 const DTS = /\.d\.ts$/;
+const NODE_MODULES = '/node_modules/';
 
 /**
  * This version of the AotCompilerHost expects that the program will be compiled
@@ -48,6 +49,13 @@ export class PathMappedCompilerHost extends CompilerHost {
       // Any containing file gives the same result for absolute imports
       containingFile = this.getCanonicalFileName(path.join(this.basePath, 'index.ts'));
     }
+    if (containingFile.indexOf(NODE_MODULES) >= 0) {
+      m = m.replace(EXT, '');
+      const resolved = ts.resolveModuleName(m, containingFile, this.options, this.context).resolvedModule;
+      if (!resolved)
+        return null;
+      return this.getCanonicalFileName(resolved.resolvedFileName);
+    }
     for (const root of this.options.rootDirs || ['']) {
       const rootedContainingFile = path.join(root, containingFile);
       const resolved =
@@ -68,7 +76,7 @@ export class PathMappedCompilerHost extends CompilerHost {
    * Relativize the paths by checking candidate prefixes of the absolute path, to see if
    * they are resolvable by the moduleResolution strategy from the CompilerHost.
    */
-  fileNameToModuleName(importedFile: string, containingFile: string): string {
+  fileNameToModuleNameX(importedFile: string, containingFile: string): string {
     if (this.options.traceResolution) {
       console.error(
           'getImportPath from containingFile', containingFile, 'to importedFile', importedFile);
@@ -116,6 +124,23 @@ export class PathMappedCompilerHost extends CompilerHost {
   }
 
   getMetadataFor(filePath: string): ModuleMetadata[] {
+    if (filePath.indexOf(NODE_MODULES) >= 0) {
+      if (!this.context.fileExists(filePath))
+        return null !;
+      if (DTS.test(filePath)) {
+        const metadataPath = filePath.replace(DTS, '.metadata.json');
+        if (this.context.fileExists(metadataPath))
+          return this.readMetadata(metadataPath, filePath);
+        else
+          return [this.upgradeVersion1Metadata(
+              {'__symbolic': 'module', 'version': 1, 'metadata': {}}, filePath)];
+      } else {
+        const sf = this.getSourceFile(filePath);
+        sf.fileName = sf.fileName;
+        const metadata = this.metadataCollector.getMetadata(sf);
+        return metadata ? [metadata] : [];
+      }
+    }
     for (const root of this.options.rootDirs || []) {
       const rootedPath = path.join(root, filePath);
       if (!this.context.fileExists(rootedPath)) {
@@ -138,4 +163,13 @@ export class PathMappedCompilerHost extends CompilerHost {
     }
     return null !;
   }
+
+  loadResource(filePath: string): Promise<string>|string {
+    for (const root of this.options.rootDirs || []) {
+      const rootedPath = path.join(root, filePath);
+      if (this.context.fileExists(rootedPath))
+        return this.context.readResource(rootedPath);
+    }
+    return this.context.readResource(filePath);
+  }
 }
diff --git a/tools/@angular/tsc-wrapped/src/main.ts b/tools/@angular/tsc-wrapped/src/main.ts
index 3405cdf..d041f7d 100644
--- a/tools/@angular/tsc-wrapped/src/main.ts
+++ b/tools/@angular/tsc-wrapped/src/main.ts
@@ -13,7 +13,7 @@ import * as ts from 'typescript';
 
 import {CompilerHostAdapter, MetadataBundler} from './bundler';
 import {CliOptions} from './cli_options';
-import {MetadataWriterHost, SyntheticIndexHost} from './compiler_host';
+import {DelegatingHost, MetadataWriterHost, SyntheticIndexHost} from './compiler_host';
 import {privateEntriesToIndex} from './index_writer';
 import NgOptions from './options';
 import {check, tsc} from './tsc';
@@ -25,6 +25,48 @@ const DTS = /\.d\.ts$/;
 const JS_EXT = /(\.js|)$/;
 const TS_EXT = /\.ts$/;
 
+export class MultiRootHost extends DelegatingHost {
+  private outDir: string;
+  private rootDirs: string[];
+
+  constructor(private tsickleDelegate: tsickle.TsickleCompilerHost, private options: NgOptions) {
+    super(tsickleDelegate);
+    this.outDir = options.outDir;
+    const rootedOutput = !!options.rootedOutput && !!options.outDir && (!!options.rootDirs && options.rootDirs.length > 0);
+    this.rootDirs = rootedOutput ? options.rootDirs : null;
+  }
+
+  writeFile: ts.WriteFileCallback =
+  (fileName: string, data: string, writeByteOrderMark: boolean, onError?: (message: string) => void, sourceFiles?: ts.SourceFile[]) => {
+    var outFileName = fileName;
+    if (this.rootDirs && !!sourceFiles && sourceFiles.length > 0) {
+      const sourceFileName = sourceFiles[0].fileName;
+      for (const rootDir of this.rootDirs) {
+        const relativeFileName = path.relative(rootDir, sourceFileName);
+        if (relativeFileName.indexOf('..' + path.sep) !== 0) {
+          outFileName = path.join(path.join(this.outDir, path.dirname(relativeFileName)), path.basename(fileName));
+          if (path.extname(fileName) === '.map') {
+            const sourceMap = JSON.parse(data);
+            for (var i = 0; i < sourceMap.sources.length; i++)
+              sourceMap.sources[i] = path.relative(outFileName, path.resolve(fileName, sourceMap.sources[i]))
+            data = JSON.stringify(sourceMap);
+          }
+          break;
+        }
+      }
+    }
+    this.tsickleDelegate.writeFile(outFileName, data, writeByteOrderMark, onError, sourceFiles);
+  }
+
+  public reconfigureForRun(oldProgram: ts.Program, pass: tsickle.Pass) {
+    this.tsickleDelegate.reconfigureForRun(oldProgram, pass);
+  }
+
+  public diagnostics(): ts.Diagnostic[] {
+    return this.tsickleDelegate.diagnostics;
+  }
+}
+
 export interface CodegenExtension {
   /**
    * Returns the generated file names.
@@ -110,7 +152,7 @@ export function main(
     };
 
     const tsickleCompilerHost =
-        new tsickle.TsickleCompilerHost(host, ngOptions, tsickleCompilerHostOptions, tsickleHost);
+        new MultiRootHost(new tsickle.TsickleCompilerHost(host, ngOptions, tsickleCompilerHostOptions, tsickleHost), ngOptions);
 
     const program = createProgram(tsickleCompilerHost);
 
@@ -150,7 +192,7 @@ export function main(
         // A program can be re-used only once; save the programWithCodegen to be reused by
         // metadataWriter
         programForJsEmit = createProgram(tsickleCompilerHost);
-        check(tsickleCompilerHost.diagnostics);
+        check(tsickleCompilerHost.diagnostics());
         if (diagnostics) console.timeEnd('NG downlevel');
       }
 
@@ -158,7 +200,7 @@ export function main(
         if (diagnostics) console.time('NG JSDoc');
         tsickleCompilerHost.reconfigureForRun(programForJsEmit, tsickle.Pass.CLOSURIZE);
         programForJsEmit = createProgram(tsickleCompilerHost);
-        check(tsickleCompilerHost.diagnostics);
+        check(tsickleCompilerHost.diagnostics());
         if (diagnostics) console.timeEnd('NG JSDoc');
       }
 
diff --git a/tools/@angular/tsc-wrapped/src/options.ts b/tools/@angular/tsc-wrapped/src/options.ts
index f9ad2bd..c374daf 100644
--- a/tools/@angular/tsc-wrapped/src/options.ts
+++ b/tools/@angular/tsc-wrapped/src/options.ts
@@ -90,6 +90,8 @@ interface Options extends ts.CompilerOptions {
   // matched by the `files` / `includes` in the `tsconfig.json`.
   // This is off by default.
   alwaysCompileGeneratedCode?: boolean;
+
+  rootedOutput?: boolean;
 }
 
 export default Options;
